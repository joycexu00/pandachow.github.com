---
layout: post
title: 模拟退火算法学习笔记(二)
categories:
- 伪技术
tags:
- MATLAB
- 人工智能
- 函数
- 数值分析
- 算法
---

实践阿实践, 这里要体现出实践的价值, 前面的理论部分都是为了代码的实现做准备的而已. 这篇文章实在看了很多大牛的笔记和参考很多书籍之后才出炉的, 就是这样, 仍然不能很充分理解 SA 的核心, = =# 罢了罢了笔记就简单写写, 能理解多少算多少把.

这里考虑了一下, 还是决定用经典的[TSP问题](http://baike.baidu.com/view/614849.htm)来作为MATLAB实现的示例, 这个问题简单描述一下就是: 一个商人要到n个不同的城市去推销商品, 每2个城市i和j之间的距离为$$d_ij$$, 如何才能选择一条路径使得商人每个城市走一遍之后回到起点且路径最短.

TSP是典型的组合优化问题, 并且显然是一个 NP难问题, TSP描述起来非常简单, 早期也有很多方法来解答, 包括像分支定界, 线性规划, 动态规划等等, 但是这些办法在城市的数目超过100(或者非常大)之后就很难奏效了, 因为此时的可能的路径的数目是非常可怕的, 从而靠这些办法来获得全局最优解是有这明显的限制.

## 算法设计步骤:
### 1. TSP 问题的解空间和初始解

TSP的解空间$$S$$是遍访每个城市恰好一次的所有回路, 是所有城市的排列的集合. TSP问题的解空间$$S$$可以表示为$${1,2,\cdots,n}$$的所有排列的集合, 也就是:
$$!S=\{(c_1,c_2,\cdots,c_n)|(c_1,c_2,\cdots,c_n) is\;one\;arrangements\;of\;\{1,2,\cdots,n\} \}$$
其中, 每一个排列$$s_i$$表示遍访n个城市的一个路径, $$c_j=j$$表示第i次访问城市j. 由于模拟退火算法的最优解和初始状态没有很强的依赖关系, 故初始解可以为随机函数生成一个$${1,2,\cdots,n}$$的随机排列最为$$s_0$$.

### 2. 目标函数
TSP问题的目标函数即为访问所有城市的路径总长度, 也可以称之为代价函数:
$$!C(c_1,c_2,\cdots,c_n)=\sum\limits_{i=1}^{n-1}d(c_i,c_{i+1}+d(c_1,c_n))$$
现在TSP问题的求解就是通过模拟退火算法求出目标函数$$C(c_1,c_2,\cdots,c_n)$$的最小值, 相应地, $$\textbf{S}=(c_1^*,c_2^*,\cdots,c_n^*)$$即为TSP问题的最优解.

### 3. 新解的产生
新解的产生对问题的求解非常重要, 新解可以通过分别或者交替使用以下两种方式产生:
	
1. 二变换法: 任选序号$$u, v$$(设$$u<v<n$$), 交换u和v之间的访问顺序;
2. 三变换法: 任选序号$$u, v, w$$(设$$u\leq v<w$$), 将u和v之间的路径插到w之后访问.

### 4. 目标函数差
计算变换前和变换后目标函数的差值:
$$!\delta C^'=C(s_i^{'})-C(s_i)$$

### 5. Metropolis接受准则
以新解与当前解的目标函数差定义接受概率, 即:
$$!P=\begin{cases}1, \Delta^{'}

结果:

	the best solution is
	Columns 1 through 14
	12 28 27 26 47 13 14 52 11 51 33 43 10 9
	Columns 15 through 28
	8 41 19 45 32 49 1 22 31 18 3 17 21 42
	Columns 29 through 42
	7 2 30 23 20 50 29 16 46 44 34 35 36 39
	Columns 43 through 52
	40 37 38 48 24 5 15 6 4 25
	the nearest solution is
	7.5444e+03

可以看到结果和官方给出的用分支定界最优解已经非常接近.

## 特别注意
由于每个问题的城市数目和距离并不相同, 所有对于每个问题的如果想得到比较好的解, 需要对起始温度, 衰减函数, Markov链长度进行适当的调整, 当然也可以改变使用的接受函数.